<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Sketcher</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; touch-action: none; }
  #ui-container, #toolbox, #visibility-container {
      position: absolute;
      left: 24px;
      right: auto;
      z-index: 10;
      background: rgba(255,255,255,0.95);
      padding: 10px;
      border-radius: 4px;
      font-family: sans-serif;
      font-size: 14px;
      max-width: 320px;
      min-width: 180px;
      box-sizing: border-box;
      box-shadow: 0 2px 12px rgba(0,0,0,0.08);
    }
    #ui-container { top: 24px; left: 24px; right: auto; max-width: 320px; }
  #toolbox { display: none; top: 80px; left: 24px; right: auto; }
    #visibility-container { bottom: 24px; left: 24px; right: auto; max-width: 320px; }
    #objectList div { display: flex; align-items: center; margin-bottom: 4px; }
    #objectList input[type="checkbox"] { margin-right: 6px; }
    #objectList span { flex: 1; cursor: pointer; }
    @media (max-width: 600px) {
  #ui-container, #visibility-container {
        left: 0; right: 0; max-width: 100vw; min-width: 0; padding: 6px; font-size: 12px;
        box-shadow: none;
      }
      #ui-container { top: 0; }
      #visibility-container { bottom: 0; }
      button, select, input { font-size: 14px !important; }
    }
    /* Icon button styling for Add Floor/Wall */
    .icon-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 40px; height: 40px;
      min-width: 40px; min-height: 40px;
      margin-right: 8px;
      background: transparent;
      border: none;
      box-shadow: none;
      cursor: pointer;
    }
    .icon-btn:hover { background: transparent; }
    .icon-btn:focus-visible { outline: 2px solid #888; outline-offset: 2px; border-radius: 6px; }
    /* Map modal */
    #mapModalBackdrop {
      position: fixed; inset: 0; background: rgba(0,0,0,0.45); display: none; align-items: center; justify-content: center; z-index: 1000;
    }
    #mapModal {
      background: #fff; width: min(92vw, 820px); height: min(80vh, 620px); border-radius: 8px; box-shadow: 0 10px 40px rgba(0,0,0,0.25); display: flex; flex-direction: column; overflow: hidden;
    }
    #mapModalHeader { padding: 8px 12px; display: flex; align-items: center; gap: 8px; border-bottom: 1px solid #eee; }
    #mapModalHeader input { flex: 1; padding: 6px 8px; font-size: 14px; border: 1px solid #ddd; border-radius: 4px; }
    #mapContainer { flex: 1; }
    #mapModalFooter { padding: 8px 12px; border-top: 1px solid #eee; display: flex; gap: 8px; justify-content: space-between; align-items: center; }
    #mapModalFooter .btn { padding: 6px 10px; font-size: 14px; border: 1px solid #ccc; border-radius: 4px; background: #f7f7f7; cursor: pointer; }
    #mapModalFooter .btn.primary { background: #222; color: #fff; border-color: #222; }
    .icon-btn svg { width: 22px; height: 22px; display: block; }
    .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,1px,1px); white-space: nowrap; border: 0; }
  /* Map draw selection styles */
  .leaflet-container.crosshair { cursor: crosshair; }
  .selection-rect { pointer-events:none; border:2px dashed #0078ff; background:rgba(0,120,255,0.08); }
  /* Toolbox: snap to content width and stack vertically */
  #toolbox { display: none; padding: 4px; min-width: auto; max-width: none; width: auto; display: inline-block; }
  #toolbox .icon-btn { display: flex; margin-right: 0; margin-bottom: 8px; }
  #toolbox .icon-btn:last-child { margin-bottom: 0; }
  </style>
</head>
<body>
  <script type="importmap">
    {
      "imports": {
        "three": "./js/vendor/three.module.js"
      }
    }
  </script>
  <div id="ui-container">
  <div>
      <label for="modeSelect" data-i18n="mode.label">Mode:</label>
      <select id="modeSelect">
        <option value="draw" selected data-i18n="mode.create">Create</option>
        <option value="edit" data-i18n="mode.edit">Edit</option>
        <option value="import" data-i18n="mode.import">Import</option>
        <option value="ar" data-i18n="mode.ar">AR View</option>
      </select>
    </div>
    <div id="draw-ui" style="margin-top:6px;">
  <label for="height" data-i18n="draw.heightLabel">Height (feet):</label>
  <input id="height" type="number" step="0.1" value="1">
    </div>
    <div id="edit-ui" style="margin-top:6px; display:none;">
      <!-- Move + Rotate gizmos are both active in Edit mode -->
      <button id="snapFloor" style="margin-left:8px;" data-i18n="edit.snapFloor">Return to Floor</button>
      <button id="groupBtn" style="margin-left:8px;" data-i18n="edit.groupSelected">Group Selected</button>
    </div>
    <button id="arButton" style="margin-top:10px; display:none;" data-i18n="buttons.enterAR">Enter AR</button>
    <button id="exportScene" style="margin-top:10px;" data-i18n="buttons.exportOBJ">Export Scene (OBJ)</button>
    <div style="margin-top:6px; font-size:12px; color:#333;" data-i18n="hints.main">
      Create: drag • Edit: select/move/rotate • Import: place • Export scene • Mobile: tap to select • Edit: one finger orbits, pinch to zoom/pan • Create/Import: one finger draws/places
    </div>
    
    <input id="modelInput" type="file" accept=".gltf,.glb,.obj" style="display:none;">
    <div id="uploadStatus" style="font-size:12px; color:#555; margin-top:4px;" data-i18n="status.noModelSelected">No model selected</div>
  </div>
  <div id="toolbox">
    <button id="addFloor" class="icon-btn" title="Add Floor" aria-label="Add Floor">
      <span class="sr-only">Add Floor</span>
      <!-- Floor icon: a flat square -->
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <rect x="5" y="5" width="14" height="14" fill="none" stroke="#222" stroke-width="2" rx="2" ry="2" />
      </svg>
    </button>
    <button id="addWall" class="icon-btn" title="Add Wall" aria-label="Add Wall">
      <span class="sr-only">Add Wall</span>
      <!-- Wall icon: a vertical rectangle sitting on a base line -->
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <rect x="9" y="4" width="6" height="12" fill="#999" stroke="#222" stroke-width="1.5" />
        <line x1="4" y1="19" x2="20" y2="19" stroke="#222" stroke-width="2" />
      </svg>
    </button>
    <button id="uploadModel" class="icon-btn" title="Upload Model" aria-label="Upload Model">
      <span class="sr-only">Upload Model</span>
      <!-- Upload icon: arrow into a tray -->
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M12 3l4 4h-3v6h-2V7H8l4-4z" fill="#222"/>
        <path d="M5 14h14v5H5z" fill="none" stroke="#222" stroke-width="2"/>
      </svg>
    </button>
    <button id="mapImport" class="icon-btn" title="Import from Map" aria-label="Import from Map">
      <span class="sr-only">Import from Map</span>
      <!-- Map icon -->
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M3 6l6-2 6 2 6-2v14l-6 2-6-2-6 2V6z" fill="none" stroke="#222" stroke-width="1.8"/>
        <circle cx="12" cy="12" r="2" fill="#222"/>
      </svg>
    </button>
  </div>
  <div id="visibility-container">
    <strong data-i18n="visibility.title">Visibility</strong>
    <div id="objectList"></div>
  </div>
  <div id="version-badge" style="position:fixed; right:12px; bottom:12px; background:rgba(0,0,0,0.7); color:#fff; padding:6px 8px; border-radius:4px; font-family:sans-serif; font-size:12px; z-index:20;">
    v…
  </div>
  <div id="error-banner" style="position:fixed;left:0;right:0;bottom:0;background:#ffe3e3;color:#900;padding:6px 10px;font-family:sans-serif;font-size:12px;display:none;z-index:9999;"></div>
  <!-- Map modal overlay -->
  <div id="mapModalBackdrop">
    <div id="mapModal">
      <div id="mapModalHeader">
        <input type="text" id="mapSearch" placeholder="Search location (OSM/Nominatim)">
        <button id="mapSearchBtn" class="btn">Search</button>
        <button id="mapDrawToggle" class="btn" aria-pressed="false" title="Draw a selection box on the map">Draw Box</button>
        <button id="mapCloseBtn" class="btn">Close</button>
      </div>
      <div id="mapContainer"></div>
      <div id="mapModalFooter">
        <div style="font-size:12px;color:#444;">
          Tip: Click "Draw Box", then drag on the map to select an area. If no box is drawn, the current view is used.
          <div style="margin-top:4px;color:#666;">Imagery © Esri — World Imagery; Map data © OpenStreetMap contributors.</div>
        </div>
        <div>
          <button id="mapUseFlat" class="btn">Use selected area (Flat)</button>
          <button id="mapUseTopo" class="btn primary">Use selected area (Topography)</button>
        </div>
      </div>
    </div>
  </div>
  <script type="module">
  import * as THREE from './js/vendor/three.module.js';
  import { clearSelectionOutlines as clearOutlinesMod, rebuildSelectionOutlines as rebuildOutlinesMod } from './js/app/outlines.js';
  import { getWorldMatrix as getWorldMatrixMod, setWorldMatrix as setWorldMatrixMod } from './js/app/transforms.js';
  import { GLTFLoader } from './js/vendor/GLTFLoader.js';
  import { OBJLoader }  from './js/vendor/OBJLoader.js';
  import { OrbitControls } from './js/vendor/OrbitControls.js';
  import { TransformControls } from './js/vendor/TransformControls.js';
  import { OBJExporter } from './js/vendor/OBJExporter.js';
  import { setupMapImport } from './js/app/map-import.js';
  
  // three.js examples CDN base for optional exporters (match local three version)
  const THREE_EXAMPLES_CDN_BASE = 'https://unpkg.com/three@0.155.0/examples/jsm';
  
  // Lightweight version badge
  (async () => {
    try {
      const res = await fetch('./version.json', { cache: 'no-store' });
      if (res.ok) {
        const v = await res.json();
        const el = document.getElementById('version-badge');
        if (el) el.textContent = `v${v.version} — ${v.date}`;
      }
    } catch {}
  })();

    // WebXR Polyfill attempt for iOS; note: real AR may still be unsupported
    async function loadWebXRPolyfillIfNeeded() {
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
      if (isIOS && !('xr' in navigator)) {
        try { await import('./js/vendor/webxr-polyfill.module.js'); } catch {}
      }
    }
    loadWebXRPolyfillIfNeeded();

  // Scene setup
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.01, 5000);
    camera.position.set(5,5,5); camera.lookAt(0,0,0);
  const renderer = new THREE.WebGLRenderer({ antialias:true, logarithmicDepthBuffer: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Enable WebXR AR if available
    renderer.xr.enabled = true;
    let arActive = false;

    // Grid & Lights
    // 1 foot = 1 unit. Grid is 20x20 feet, 1 foot per division.
    const grid = new THREE.GridHelper(20, 20, 0x888888, 0xcccccc); // size=20 units (feet), divisions=20 (1 foot per square)
    grid.receiveShadow = true;
    scene.add(grid);
    scene.add(new THREE.AmbientLight(0xffffff,0.5));
    const dirLight=new THREE.DirectionalLight(0xffffff,0.8);
    dirLight.position.set(5,10,7); dirLight.castShadow=true; scene.add(dirLight);

    // Controls
    const controls=new OrbitControls(camera,renderer.domElement);
    controls.enableDamping=true; controls.dampingFactor=0.05;
    controls.enablePan=true; controls.enableZoom=true;
    controls.enableRotate=true;
    controls.mouseButtons={LEFT:THREE.MOUSE.NONE,MIDDLE:THREE.MOUSE.ROTATE,RIGHT:THREE.MOUSE.PAN};
  // Default touch mapping; will be adjusted automatically per mode on touch devices
  controls.touches = { ONE: THREE.TOUCH.NONE, TWO: THREE.TOUCH.DOLLY_PAN };
    window.addEventListener('keydown',e=>{if(e.key==='Shift')controls.mouseButtons.MIDDLE=THREE.MOUSE.PAN;});
    window.addEventListener('keyup',  e=>{if(e.key==='Shift')controls.mouseButtons.MIDDLE=THREE.MOUSE.ROTATE;});
  const transformControls=new TransformControls(camera,renderer.domElement); // translate
  transformControls.setMode('translate');
  transformControls.setTranslationSnap(0.1);
  transformControls.addEventListener('dragging-changed',e=>controls.enabled=!e.value);
  scene.add(transformControls);

  const transformControlsRotate=new TransformControls(camera,renderer.domElement); // rotate
  transformControlsRotate.setMode('rotate');
  transformControlsRotate.setRotationSnap(THREE.MathUtils.degToRad(15));
  transformControlsRotate.addEventListener('dragging-changed',e=>controls.enabled=!e.value);
  scene.add(transformControlsRotate);
  // Only one gizmo active at a time
  function disableRotateGizmo(){ transformControlsRotate.enabled = false; transformControlsRotate.visible = false; }
  function enableRotateGizmo(){ transformControlsRotate.enabled = true; transformControlsRotate.visible = true; }
  function disableTranslateGizmo(){ transformControls.enabled = false; transformControls.visible = false; }
  function enableTranslateGizmo(){ transformControls.enabled = true; transformControls.visible = true; }
  transformControls.addEventListener('mouseDown', () => { disableRotateGizmo(); });
  transformControls.addEventListener('mouseUp',   () => { enableRotateGizmo(); });
  transformControlsRotate.addEventListener('mouseDown', () => { disableTranslateGizmo(); });
  transformControlsRotate.addEventListener('mouseUp',   () => { enableTranslateGizmo(); });

  // Multi-selection transform pivot (temporary gizmo target when 2+ items selected)
  const multiSelectPivot = new THREE.Object3D();
  multiSelectPivot.name = '__MultiSelectPivot';
  scene.add(multiSelectPivot);
  let multiStartPivotMatrix = new THREE.Matrix4();
  let multiStartMatrices = new Map(); // Map<Object3D, Matrix4>

    // State
    const raycaster=new THREE.Raycaster(), pointer=new THREE.Vector2();
    const groundPlane=new THREE.Plane(new THREE.Vector3(0,1,0),0);
    let mode='draw', isDragging=false, previewMesh=null;
    let startPt=new THREE.Vector3();
    const objects=[];
    const material=new THREE.MeshNormalMaterial({side:THREE.DoubleSide});
  let loadedModel=null;
  // Store outlines for all selected objects
  let selectionOutlines = [];
    // Multi-selection state
    let selectedObjects = [];

  // Outline helpers (delegated to module)
  function clearSelectionOutlines(){ selectionOutlines = clearOutlinesMod(scene, selectionOutlines); }
  function rebuildSelectionOutlines(){ selectionOutlines = clearOutlinesMod(scene, selectionOutlines); selectionOutlines = rebuildOutlinesMod(THREE, scene, selectedObjects); }

    // Helpers for multi-select gizmo
  const getWorldMatrix = getWorldMatrixMod; const setWorldMatrix = setWorldMatrixMod;
    function updateMultiSelectPivot(){
      if(selectedObjects.length < 2) return;
      // Compute centroid in world space
      const center = new THREE.Vector3();
      const tmp = new THREE.Vector3();
      selectedObjects.forEach(o=>{
        o.updateMatrixWorld();
        tmp.setFromMatrixPosition(o.matrixWorld);
        center.add(tmp);
      });
      center.multiplyScalar(1/selectedObjects.length);
      // Place pivot at center; keep world-up orientation
      setWorldMatrix(multiSelectPivot, new THREE.Matrix4().compose(
        center,
        new THREE.Quaternion(),
        new THREE.Vector3(1,1,1)
      ));
    }
    function attachTransformForSelection(){
      if(mode !== 'edit') { transformControls.detach(); transformControlsRotate.detach(); return; }
      if(selectedObjects.length === 1){
        const target = selectedObjects[0];
        transformControls.attach(target);
        transformControlsRotate.attach(target);
  enableTranslateGizmo();
  enableRotateGizmo();
      } else if(selectedObjects.length >= 2){
        updateMultiSelectPivot();
        transformControls.attach(multiSelectPivot);
        transformControlsRotate.attach(multiSelectPivot);
  enableTranslateGizmo();
  enableRotateGizmo();
      } else {
        transformControls.detach();
        transformControlsRotate.detach();
      }
    }
    function captureMultiStart(){
      multiStartPivotMatrix = getWorldMatrix(multiSelectPivot);
      multiStartMatrices.clear();
      selectedObjects.forEach(o=> multiStartMatrices.set(o, getWorldMatrix(o)));
    }
    function applyMultiDelta(){
      if(selectedObjects.length < 2) return;
      const currentPivot = getWorldMatrix(multiSelectPivot);
      const invStartPivot = multiStartPivotMatrix.clone().invert();
      const delta = new THREE.Matrix4().multiplyMatrices(currentPivot, invStartPivot);
      selectedObjects.forEach(o => {
        const startMat = multiStartMatrices.get(o);
        if(!startMat) return;
        const newWorld = new THREE.Matrix4().multiplyMatrices(delta, startMat);
        setWorldMatrix(o, newWorld);
      });
    }

    // When dragging multi-select pivot, move/rotate all selected objects
    transformControls.addEventListener('dragging-changed', e => {
      if(e.value && transformControls.object === multiSelectPivot){
        captureMultiStart();
      }
    });
    transformControls.addEventListener('objectChange', () => {
      if(transformControls.object === multiSelectPivot){
        applyMultiDelta();
      }
    });

    transformControlsRotate.addEventListener('dragging-changed', e => {
      if(e.value && transformControlsRotate.object === multiSelectPivot){
        captureMultiStart();
      }
    });
    transformControlsRotate.addEventListener('objectChange', () => {
      if(transformControlsRotate.object === multiSelectPivot){
        applyMultiDelta();
      }
    });

    // UI refs
    const uiContainer=document.getElementById('ui-container');
    const modeSelect=document.getElementById('modeSelect');
    const drawUI=document.getElementById('draw-ui');
    const editUI=document.getElementById('edit-ui');
  const toolbox=document.getElementById('toolbox');
    const uploadBtn=document.getElementById('uploadModel');
    const fileInput=document.getElementById('modelInput');
    const uploadStatus=document.getElementById('uploadStatus');
    const exportBtn=document.getElementById('exportScene');
    const snapBtn=document.getElementById('snapFloor');
    const addFloorBtn=document.getElementById('addFloor');
    const addWallBtn=document.getElementById('addWall');
    const objectList=document.getElementById('objectList');
  const arButton=document.getElementById('arButton');
  const groupBtn=document.getElementById('groupBtn');
  // No manual touch toggle; we'll detect touch automatically
  // Map modal refs
  const mapBackdrop = document.getElementById('mapModalBackdrop');
  const mapContainer = document.getElementById('mapContainer');
  const mapSearchInput = document.getElementById('mapSearch');
  const mapSearchBtn = document.getElementById('mapSearchBtn');
  const mapDrawToggle = document.getElementById('mapDrawToggle');
  const mapCloseBtn = document.getElementById('mapCloseBtn');
  const mapUseFlatBtn = document.getElementById('mapUseFlat');
  const mapUseTopoBtn = document.getElementById('mapUseTopo');
  const mapImportBtn = document.getElementById('mapImport');

    // Visibility UI
    function updateVisibilityUI(){
      objectList.innerHTML='';
      objects.forEach(obj=>{
        const div=document.createElement('div');
        const cb=document.createElement('input');
        cb.type='checkbox';
        cb.checked=obj.visible;
        cb.addEventListener('change',()=>obj.visible=cb.checked);
        const span=document.createElement('span');
        span.textContent=obj.name;
        span.style.flex='1';
        span.style.cursor='pointer';
        // Highlight if selected
        if(selectedObjects.includes(obj)) span.style.background='#ffe066';
        span.addEventListener('dblclick',()=>{
          const inp=document.createElement('input');
          inp.type='text';
          inp.value=obj.name;
          inp.style.flex='1';
          inp.addEventListener('blur',()=>{obj.name=inp.value||obj.name;updateVisibilityUI();});
          inp.addEventListener('keydown',e=>{if(e.key==='Enter')inp.blur();});
          div.replaceChild(inp,span);
          inp.focus();
        });
        // Click to select for grouping (edit mode only)
    span.addEventListener('click',e=>{
          if(mode!=='edit') return;
          if(e.ctrlKey||e.metaKey||e.shiftKey){
            // Toggle selection
            if(selectedObjects.includes(obj)){
              selectedObjects=selectedObjects.filter(o=>o!==obj);
            }else{
              selectedObjects.push(obj);
            }
            attachTransformForSelection();
            rebuildSelectionOutlines();
          }else{
            selectedObjects=[obj];
      // Attach transform controls to the selected object (group or mesh)
            attachTransformForSelection();
            rebuildSelectionOutlines();
          }
          updateVisibilityUI();
        });
        div.append(cb,span);
        objectList.append(div);
      });
    }

    // Mode change
    modeSelect.addEventListener('change',()=>{
  mode=modeSelect.value; transformControls.detach(); transformControlsRotate.detach();
      clearSelectionOutlines();
      drawUI.style.display=(mode==='draw')?'block':'none';
      editUI.style.display=(mode==='edit')?'block':'none';
  // Toolbox behavior: show in Draw and Import; filter items per mode
  const showToolbox = (mode==='draw'||mode==='import');
  toolbox.style.display = showToolbox ? 'inline-block' : 'none';
  if (showToolbox) {
    const showFloorWall = (mode==='draw');
  const showUpload   = (mode==='import');
    document.getElementById('addFloor').style.display = showFloorWall ? 'flex' : 'none';
    document.getElementById('addWall').style.display  = showFloorWall ? 'flex' : 'none';
  document.getElementById('uploadModel').style.display = showUpload ? 'flex' : 'none';
  document.getElementById('mapImport').style.display = showUpload ? 'flex' : 'none';
    toolbox.style.top = `${uiContainer.offsetTop+uiContainer.offsetHeight+10}px`;
  }
      snapBtn.style.display=(mode==='edit')?'inline-block':'none';
      // AR button visibility
      if(mode==='ar') {
        arButton.style.display = 'block';
      } else {
        arButton.style.display = 'none';
        if(renderer.xr.isPresenting) renderer.xr.getSession().end();
      }
  // Ensure touch mapping matches current mode on touch devices
  if (typeof applyAutoTouchMapping === 'function') applyAutoTouchMapping();
    });
    modeSelect.dispatchEvent(new Event('change'));

    // Helper: build a root group of exportable objects (user content only)
    function buildExportRootFromObjects(objs){
      const root = new THREE.Group();
      objs.forEach(o => root.add(o.clone(true)));
      return root;
    }

    // Prepare model for AR export: standardize materials, center on X/Z, floor at Y=0, convert feet->meters
    function prepareModelForAR(root){
      // Replace unsupported/odd materials with MeshStandardMaterial for USDZ
      root.traverse((obj) => {
        if (obj.isMesh) {
          const oldMat = obj.material;
          let color = 0xcccccc;
          if (oldMat) {
            if (Array.isArray(oldMat)) {
              obj.material = oldMat.map(m => new THREE.MeshStandardMaterial({ color: (m.color && m.color.getHex) ? m.color.getHex() : color, metalness: 0, roughness: 0.8 }));
            } else {
              if (oldMat.color && oldMat.color.getHex) color = oldMat.color.getHex();
              obj.material = new THREE.MeshStandardMaterial({ color, metalness: 0, roughness: 0.8 });
            }
          } else {
            obj.material = new THREE.MeshStandardMaterial({ color, metalness: 0, roughness: 0.8 });
          }
        }
      });
  // Center and floor the content
  root.updateMatrixWorld(true);
  const box = new THREE.Box3().setFromObject(root);
      const size = new THREE.Vector3(); box.getSize(size);
      const center = new THREE.Vector3(); box.getCenter(center);
      // Translate so X/Z centered at 0 and min Y at 0
      const translate = new THREE.Vector3(center.x, box.min.y, center.z);
      root.position.sub(translate);
      // Scale feet to meters
      const FEET_TO_METERS = 0.3048;
      root.scale.setScalar(FEET_TO_METERS);
      // Recompute just for sanity
      root.updateMatrixWorld(true);
    }

    // Helper: export USDZ and open in Quick Look (iOS)
    async function openQuickLookUSDZ() {
      // Prefer selected objects; else entire scene objects[]
      const source = (selectedObjects && selectedObjects.length) ? selectedObjects : objects;
      if (!source || !source.length) { alert('Nothing to show in AR. Create or import an object first.'); return; }
      const root = buildExportRootFromObjects(source);
      prepareModelForAR(root);
      try {
        const { USDZExporter } = await import(`${THREE_EXAMPLES_CDN_BASE}/exporters/USDZExporter.js`);
        const exporter = new USDZExporter();
        const arraybuffer = await exporter.parse(root);
        const blob = new Blob([arraybuffer], { type: 'model/vnd.usdz+zip' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.setAttribute('rel', 'ar');
        a.setAttribute('href', url);
        // Optionally add a fallback poster: a.appendChild(new Image())
        document.body.appendChild(a);
        a.click();
        setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 30000);
      } catch (e) {
        alert('Unable to generate USDZ for AR: ' + (e?.message || e));
        console.error(e);
      }
    }

    // AR Button logic (WebXR first; iOS Quick Look fallback)
    arButton.addEventListener('click', async () => {
      await loadWebXRPolyfillIfNeeded();
      const isSecure = window.isSecureContext || location.protocol === 'https:';
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
      if (!isSecure) {
        alert('AR requires HTTPS. Please host this page over https://');
        return;
      }
      try {
        const xr = navigator.xr;
        const xrSupported = xr && await xr.isSessionSupported('immersive-ar');
        if (xrSupported) {
          const session = await navigator.xr.requestSession('immersive-ar', {
            requiredFeatures: ['hit-test', 'local-floor']
          });
          renderer.xr.setSession(session);
          arActive = true;
          session.addEventListener('end', () => {
            arActive = false;
            modeSelect.value = 'draw';
            modeSelect.dispatchEvent(new Event('change'));
          });
        } else if (isIOS) {
          // Fallback: Apple Quick Look using USDZ
          await openQuickLookUSDZ();
        } else {
          alert('AR not supported on this device or browser.');
        }
      } catch (e) {
        alert('Failed to start AR: ' + (e?.message || e));
        console.error(e);
      }
    });

  // No transform mode dropdown: both move and rotate gizmos are active in Edit mode

  // Upload model
    uploadBtn.addEventListener('click',()=>fileInput.click());
  fileInput.addEventListener('change',e=>{const file=e.target.files[0];if(!file)return;const url=URL.createObjectURL(file);const loader=file.name.endsWith('.obj')?new OBJLoader():new GLTFLoader();loader.load(url,gltf=>{loadedModel=gltf.scene||gltf;uploadStatus.textContent=file.name;URL.revokeObjectURL(url);});});

    // Export: only user-created/imported objects (exclude grid, lights, gizmos)
    exportBtn.addEventListener('click',()=>{
      const exporter=new OBJExporter();
      const root=new THREE.Group();
      objects.forEach(o=>root.add(o.clone(true)));
      const data=exporter.parse(root);
      const blob=new Blob([data],{type:'text/plain'});
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download='scene.obj';
      a.click();
      URL.revokeObjectURL(a.href);
    });

  // Language selection removed; default is English

    // Helpers
  function getPointer(e){const rect=renderer.domElement.getBoundingClientRect();pointer.x=((e.clientX-rect.left)/rect.width)*2-1;pointer.y=-((e.clientY-rect.top)/rect.height)*2+1;}
  function intersectGround(){const pt=new THREE.Vector3();raycaster.ray.intersectPlane(groundPlane,pt);return pt;}
  function intersectAtY(y){const plane=new THREE.Plane(new THREE.Vector3(0,1,0),-y);const pt=new THREE.Vector3();return raycaster.ray.intersectPlane(plane,pt)?pt:null;}

    // Dynamically adjust camera near/far and controls distance to fit scene content
    function updateCameraClipping(){
      if (!objects.length) return;
      const box = new THREE.Box3();
      objects.forEach(o => box.expandByObject(o));
      if (box.isEmpty()) return;
      const size = new THREE.Vector3(); box.getSize(size);
      const radius = Math.max(size.x, size.y, size.z) * 0.75;
      const far = Math.min(100000, Math.max(1000, radius * 12));
      camera.near = Math.max(0.01, far / 50000);
      camera.far = far;
      camera.updateProjectionMatrix();
      if (controls){
        controls.maxDistance = far * 0.95;
      }
    }

    // Streamlining helpers
    function selectableTargets(){
      return objects.flatMap(o => o.type === 'Group' ? [o, ...o.children] : [o]);
    }
    function addObjectToScene(obj, { select = false } = {}){
      scene.add(obj);
      objects.push(obj);
      updateVisibilityUI();
      updateCameraClipping();
      if (select){
        selectedObjects = [obj];
        attachTransformForSelection();
        rebuildSelectionOutlines();
      }
    }

    // Automatic touch mapping based on device + mode
    const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);
    function applyAutoTouchMapping(){
      if(isTouchDevice){
        // Edit: single finger orbits; pinch pans/zooms. Other modes: leave one finger free for app actions.
        controls.touches = (mode === 'edit')
          ? { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN }
          : { ONE: THREE.TOUCH.NONE,   TWO: THREE.TOUCH.DOLLY_PAN };
      } else {
        // Desktop: prefer app actions on single pointer
        controls.touches = { ONE: THREE.TOUCH.NONE, TWO: THREE.TOUCH.DOLLY_PAN };
      }
    }
    applyAutoTouchMapping();


    // Interaction
  // Prevent browser scroll/zoom while finger-panning on canvas (bind once)
  renderer.domElement.addEventListener('touchmove', e => { e.preventDefault(); }, { passive: false });

  // Track active touch pointers to avoid accidental actions with multi-touch
  const activeTouchPointers = new Set();
  renderer.domElement.addEventListener('pointerup', e => { if(e.pointerType==='touch') activeTouchPointers.delete(e.pointerId); });
  renderer.domElement.addEventListener('pointercancel', e => { if(e.pointerType==='touch') activeTouchPointers.delete(e.pointerId); });

  let drawBaseY = 0;
  const SURFACE_EPS = 0.01;
  renderer.domElement.addEventListener('pointerdown',e=>{
  // Prevent deselection and allow gizmo interaction even when not overlapping group
  if (transformControls.dragging || transformControlsRotate.dragging) return;
  // If multiple touches are present, avoid starting select/draw
  if (e.pointerType==='touch') { activeTouchPointers.add(e.pointerId); if(activeTouchPointers.size>1) return; }
  getPointer(e); raycaster.setFromCamera(pointer,camera); if(e.button!==0)return;
      if(mode==='draw'){
        // Pick draw plane: top-most intersected object surface Y, else ground Y=0
        const hits=raycaster.intersectObjects(selectableTargets(),true);
        drawBaseY = hits.length ? (hits[0].point.y) : 0;
        const pt = intersectAtY(drawBaseY) || intersectGround();
        if(!pt) return; isDragging=true; startPt.copy(pt); controls.enabled=false;
      } else if(mode==='import'&&loadedModel){
        // Try to drop the model onto the top-most intersected surface; fallback to ground
        const hits=raycaster.intersectObjects(selectableTargets(),true);
        let dropPoint = null;
        if (hits.length) dropPoint = hits[0].point.clone().add(new THREE.Vector3(0, SURFACE_EPS, 0));
        else dropPoint = intersectGround();
        if(!dropPoint) return; const clone=loadedModel.clone(); clone.position.copy(dropPoint); addObjectToScene(clone);
      } else if(mode==='edit'){
        // On touch in Edit: one-finger is reserved for orbit; use tap-to-select on pointerup
        if(e.pointerType==='touch'){
          e.target.__tapStart = { x: e.clientX, y: e.clientY, t: performance.now() };
          return;
        }
        // Make sure raycaster can select both meshes and groups
        // Flatten objects array to include groups and their children for intersection
        const selectableObjects = objects.flatMap(obj => obj.type === 'Group' ? [obj, ...obj.children] : [obj]);
        const hits=raycaster.intersectObjects(selectableObjects,true);
        if(hits.length){
          let obj=hits[0].object;
          // If the object is a child of a group, select the group instead
          while(obj.parent && obj.parent.type === 'Group' && objects.includes(obj.parent)) {
            obj = obj.parent;
          }
          // Multi-select logic
           if(e.shiftKey||e.ctrlKey||e.metaKey){
            if(selectedObjects.includes(obj)){
              selectedObjects=selectedObjects.filter(o=>o!==obj);
            }else{
              selectedObjects.push(obj);
            }
            attachTransformForSelection();
            rebuildSelectionOutlines();
          }else{
            selectedObjects=[obj];
            attachTransformForSelection();
            rebuildSelectionOutlines();
          }
          rebuildSelectionOutlines();
          updateVisibilityUI();
        } else {
          transformControls.detach(); transformControlsRotate.detach();
          clearSelectionOutlines();
          selectedObjects=[];
          updateVisibilityUI();
        }
      } else {
        transformControls.detach(); transformControlsRotate.detach();
      }
    });

  // Handle tap-to-select on touch in Edit mode
    renderer.domElement.addEventListener('pointerup', e => {
      if(e.pointerType==='touch'){
        const start = e.target.__tapStart;
        activeTouchPointers.delete(e.pointerId);
    if(mode==='edit' && start){
          const dt = performance.now() - start.t;
          const dx = Math.abs(e.clientX - start.x);
          const dy = Math.abs(e.clientY - start.y);
          // Consider it a tap if short and small movement
          if(dt < 300 && dx < 8 && dy < 8){
            getPointer(e); raycaster.setFromCamera(pointer,camera);
            const selectableObjects = objects.flatMap(obj => obj.type === 'Group' ? [obj, ...obj.children] : [obj]);
            const hits=raycaster.intersectObjects(selectableObjects,true);
            if(hits.length){
              let obj=hits[0].object;
              while(obj.parent && obj.parent.type === 'Group' && objects.includes(obj.parent)) obj = obj.parent;
              selectedObjects=[obj]; attachTransformForSelection(); rebuildSelectionOutlines(); updateVisibilityUI();
            } else {
              // Clear selection on empty tap
              transformControls.detach(); transformControlsRotate.detach();
              clearSelectionOutlines();
              selectedObjects=[];
              updateVisibilityUI();
            }
          }
          e.target.__tapStart = undefined;
        }
      }
    });

    // Grouping logic (bind once)
    groupBtn.addEventListener('click',()=>{
      if(selectedObjects.length<2) return;

      // Compute center of selected objects
      const center = new THREE.Vector3();
      selectedObjects.forEach(obj => {
        obj.updateMatrixWorld();
        const pos = new THREE.Vector3();
        pos.setFromMatrixPosition(obj.matrixWorld);
        center.add(pos);
      });
      center.multiplyScalar(1 / selectedObjects.length);

      // Remove from scene and objects list
      selectedObjects.forEach(obj=>{
        scene.remove(obj);
        const idx=objects.indexOf(obj);
        if(idx>-1) objects.splice(idx,1);
      });

      // Create group at center
      const group=new THREE.Group();
      group.position.copy(center);
      selectedObjects.forEach(obj=>{
        obj.updateMatrixWorld();
        const worldPos = new THREE.Vector3();
        worldPos.setFromMatrixPosition(obj.matrixWorld);
        obj.position.copy(worldPos.sub(center));
        group.add(obj);
      });
      group.name='Group '+(objects.filter(o=>o.type==='Group').length+1);
  scene.add(group);
  objects.push(group);
  selectedObjects=[group];
  attachTransformForSelection();
  rebuildSelectionOutlines();
  updateVisibilityUI();
  updateCameraClipping();
    });

  renderer.domElement.addEventListener('pointermove',e=>{if(!isDragging)return;getPointer(e);raycaster.setFromCamera(pointer,camera);const pt=intersectAtY(drawBaseY)||intersectGround();if(!pt)return;const dx=pt.x-startPt.x,dz=pt.z-startPt.z;const sx=Math.abs(dx)||0.01,sz=Math.abs(dz)||0.01;const h=parseFloat(document.getElementById('height').value)||1;const cx=startPt.x+dx/2,cy=drawBaseY+h/2,cz=startPt.z+dz/2; if(previewMesh){scene.remove(previewMesh);previewMesh.geometry.dispose();previewMesh.material.dispose();}previewMesh=new THREE.Mesh(new THREE.BoxGeometry(sx,h,sz),material);previewMesh.position.set(cx,cy,cz);scene.add(previewMesh);});

  window.addEventListener('pointerup',e=>{if(e.button===0&&isDragging){isDragging=false;controls.enabled=true; if(previewMesh){const mesh=new THREE.Mesh(previewMesh.geometry.clone(),material.clone());mesh.position.copy(previewMesh.position);mesh.castShadow=true;mesh.receiveShadow=true;mesh.name=`Box ${objects.length+1}`;scene.add(mesh);objects.push(mesh);scene.remove(previewMesh);previewMesh=null;updateVisibilityUI(); updateCameraClipping();}}});

    // Add floor/wall
  document.getElementById('addFloor').addEventListener('click',()=>{const thickness=0.333;const floor=new THREE.Mesh(new THREE.BoxGeometry(10,thickness,10),material);floor.position.set(0,thickness/2,0);floor.name='Floor';addObjectToScene(floor);});
  document.getElementById('addWall').addEventListener('click',()=>{const thickness=0.333;const wall=new THREE.Mesh(new THREE.BoxGeometry(10,8,thickness),material);wall.position.set(0,4,-thickness/2);wall.name='Wall';scene.add(wall);objects.push(wall);updateVisibilityUI(); updateCameraClipping();});

  // Boolean buttons removed

    // Return to Floor
    snapBtn.addEventListener('click',()=>{
      if(selectedObjects.length >= 2){
        // Move the multi selection such that the lowest minY among all rests on y=0
        let minY = Infinity;
        const box = new THREE.Box3();
        selectedObjects.forEach(o=>{ box.setFromObject(o); if(box.min.y < minY) minY = box.min.y; });
        if(isFinite(minY) && Math.abs(minY) > 1e-6){
          const T = new THREE.Matrix4().makeTranslation(0, -minY, 0);
          selectedObjects.forEach(o=>{
            const current = getWorldMatrix(o);
            setWorldMatrix(o, new THREE.Matrix4().multiplyMatrices(T, current));
          });
          updateMultiSelectPivot();
          rebuildSelectionOutlines();
        }
      } else {
        const sel=transformControls.object; if(sel){ const box=new THREE.Box3().setFromObject(sel); const minY=box.min.y; sel.position.y-=minY; }
      }
    });

    // Delete (supports multi-select)
    window.addEventListener('keydown',e=>{
      if(mode==='edit'&&(e.key==='Delete'||e.key==='Backspace')){
        const toDelete = selectedObjects.length ? [...selectedObjects] : (transformControls.object ? [transformControls.object] : []);
  toDelete.forEach(sel=>{
          scene.remove(sel);
          const idx=objects.indexOf(sel);
          if(idx>-1)objects.splice(idx,1);
        });
  selectedObjects = [];
        transformControls.detach();
  clearSelectionOutlines();
  updateVisibilityUI();
  updateCameraClipping();
      }
    });

    // ESC to cancel drawing preview
    window.addEventListener('keydown',e=>{
      if(e.key==='Escape' && isDragging){
        isDragging=false; controls.enabled=true;
        if(previewMesh){
          scene.remove(previewMesh);
          if (previewMesh.geometry) previewMesh.geometry.dispose();
          if (previewMesh.material && previewMesh.material.dispose) previewMesh.material.dispose();
          previewMesh=null;
        }
      }
    });

    // Resize & single animation loop with AR support
    window.addEventListener('resize',()=>{camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);});
    // Keep outlines in sync while dragging single object too
    transformControls.addEventListener('objectChange', () => {
      rebuildSelectionOutlines();
    });
    transformControlsRotate.addEventListener('objectChange', () => {
      rebuildSelectionOutlines();
    });

    renderer.setAnimationLoop(() => {
      try {
        if (!arActive) controls.update();
        renderer.render(scene, camera);
        const banner = document.getElementById('error-banner');
        if (banner) banner.style.display = 'none';
      } catch (err) {
        const banner = document.getElementById('error-banner');
        if (banner) { banner.textContent = 'Render error: ' + (err?.message || err); banner.style.display = 'block'; }
        // Re-throw to surface in console for debugging
        console.error(err);
      }
    });

    // Map Import Logic moved to module: initialize with element refs
    const mapImport = setupMapImport({
      THREE,
      renderer,
      fallbackMaterial: material,
      addObjectToScene,
      elements: {
        backdrop: mapBackdrop,
        container: mapContainer,
        searchInput: mapSearchInput,
        searchBtn: mapSearchBtn,
        closeBtn: mapCloseBtn,
        useFlatBtn: mapUseFlatBtn,
        useTopoBtn: mapUseTopoBtn,
        drawToggleBtn: mapDrawToggle,
        importBtn: mapImportBtn,
      }
    });
  </script>
</body>
</html>